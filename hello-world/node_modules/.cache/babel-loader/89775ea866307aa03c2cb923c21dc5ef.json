{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\User\\\\source\\\\repos\\\\Learning\\\\React\\\\hello-world\\\\src\\\\Baby2.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useEffect } from 'react'; // 和隔壁的Baby(class component)對比\n// 這個是 function compoent\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst Baby2 = props => {\n  _s();\n\n  //這個 Baby2 的方法，接收 props 的參數\n\n  /* 把state變成useState */\n  const [isGetData, setGetData] = useState(false);\n  const [Mom, setMom] = useState(\"\");\n  const [isRightDad, setRightDad] = useState(false); // useState 是什麼？\n  // 官網解釋︰const [state, setState] = useState(initialState);\n  // 簡化宣告變數，設定初始值及其更改變數的方法。\n\n  /* 把class 的 member function改成「function中的function」 */\n  // 單寫這個方法，在孩子出生後，也不會被自動觸發去找媽媽。\n\n  const ajaxSimulator = () => {\n    setTimeout(() => {\n      setGetData(true);\n      setMom(\"May\");\n    }, 3000);\n  }; // 它放的位置是有講究的，不能放在 If 後面\n\n\n  useEffect(() => {\n    ajaxSimulator();\n    /* 上面是 componentDidMount */\n  }, []); // 單寫這個方法，會無法召喚多次。只有第一次生成才會跑。\n\n  const checkDad = () => {\n    if (props.dad === \"Chang\") setRightDad(true);else setRightDad(false);\n  }; // 可以放多個 UseEffect 是這個意思\n\n\n  useEffect(() => {\n    checkDad();\n    /* 上面是 componentDidMount和componentDidUpdate */\n  }, [props.dad]);\n  /* 加入監控的props.dad */\n  // 不知道為什麼是紅線，但還是能跑！(重開後就沒有紅線了。)\n\n  if (isRightDad === false) return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: \"\\u6211\\u7238\\u662F\\u8001\\u738B\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 50,\n    columnNumber: 13\n  }, this);else if (isGetData === false) //是生父，就去找媽媽，但還沒找到\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      id: \"msg\",\n      children: \"\\u6211\\u7238\\u662F\\u6B63\\u78BA\\u7684\\u5F35\\u5148\\u751F\\uFF0C\\u5ABD\\u5ABD\\u8B80\\u53D6\\u4E2D\\u2026\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 54,\n      columnNumber: 13\n    }, this);else // 找到媽媽了。\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      id: \"msg\",\n      children: [\"\\u6211\\u7238\\u662F\\u6B63\\u78BA\\u7684\\u5F35\\u5148\\u751F\\uFF0C\\u5F35\\u592A\\u592A\\u662F\", Mom]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 58,\n      columnNumber: 13\n    }, this); // 這個方法中，唯一個If else，可能是因為涉及return ，所以分開多個if else 就會出錯。\n};\n\n_s(Baby2, \"jGAL3jfCH7yT038fczSPS6WoO5A=\");\n\n_c = Baby2;\nexport default Baby2;\n\nvar _c;\n\n$RefreshReg$(_c, \"Baby2\");","map":{"version":3,"names":["React","useState","useEffect","Baby2","props","isGetData","setGetData","Mom","setMom","isRightDad","setRightDad","ajaxSimulator","setTimeout","checkDad","dad"],"sources":["C:/Users/User/source/repos/Learning/React/hello-world/src/Baby2.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\r\n\r\n// 和隔壁的Baby(class component)對比\r\n// 這個是 function compoent\r\nconst Baby2=(props)=>{ //這個 Baby2 的方法，接收 props 的參數\r\n\r\n    /* 把state變成useState */\r\n\r\n    const [isGetData,setGetData]=useState(false);   \r\n    const [Mom,setMom]=useState(\"\");               \r\n    const [isRightDad,setRightDad]=useState(false); \r\n    \r\n    // useState 是什麼？\r\n    // 官網解釋︰const [state, setState] = useState(initialState);\r\n    // 簡化宣告變數，設定初始值及其更改變數的方法。\r\n\r\n    /* 把class 的 member function改成「function中的function」 */\r\n\r\n    // 單寫這個方法，在孩子出生後，也不會被自動觸發去找媽媽。\r\n    const ajaxSimulator=()=>{\r\n        setTimeout(()=>{\r\n            setGetData(true);\r\n            setMom(\"May\");\r\n        },3000)\r\n    }\r\n    // 它放的位置是有講究的，不能放在 If 後面\r\n    useEffect(() => {\r\n        ajaxSimulator();\r\n        /* 上面是 componentDidMount */  \r\n    }, []);\r\n\r\n    // 單寫這個方法，會無法召喚多次。只有第一次生成才會跑。\r\n    const checkDad=()=>{\r\n        if(props.dad===\"Chang\")\r\n            setRightDad(true)\r\n        else\r\n            setRightDad(false)\r\n    }\r\n\r\n    // 可以放多個 UseEffect 是這個意思\r\n    useEffect(() => {\r\n        checkDad();   \r\n        /* 上面是 componentDidMount和componentDidUpdate */    \r\n    }, [ props.dad ]); /* 加入監控的props.dad */ \r\n\r\n    // 不知道為什麼是紅線，但還是能跑！(重開後就沒有紅線了。)\r\n\r\n    if(isRightDad===false)\r\n        return(\r\n            <div>我爸是老王</div>\r\n        ); \r\n    else if(isGetData===false)//是生父，就去找媽媽，但還沒找到\r\n        return(\r\n            <div id=\"msg\">我爸是正確的張先生，媽媽讀取中…</div>\r\n        );\r\n    else// 找到媽媽了。\r\n        return(\r\n            <div id=\"msg\">我爸是正確的張先生，張太太是{Mom}</div>\r\n    );  \r\n\r\n    // 這個方法中，唯一個If else，可能是因為涉及return ，所以分開多個if else 就會出錯。\r\n\r\n}\r\nexport default Baby2;"],"mappings":";;;AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,SAA1B,QAA2C,OAA3C,C,CAEA;AACA;;;;AACA,MAAMC,KAAK,GAAEC,KAAD,IAAS;EAAA;;EAAE;;EAEnB;EAEA,MAAM,CAACC,SAAD,EAAWC,UAAX,IAAuBL,QAAQ,CAAC,KAAD,CAArC;EACA,MAAM,CAACM,GAAD,EAAKC,MAAL,IAAaP,QAAQ,CAAC,EAAD,CAA3B;EACA,MAAM,CAACQ,UAAD,EAAYC,WAAZ,IAAyBT,QAAQ,CAAC,KAAD,CAAvC,CANiB,CAQjB;EACA;EACA;;EAEA;EAEA;;EACA,MAAMU,aAAa,GAAC,MAAI;IACpBC,UAAU,CAAC,MAAI;MACXN,UAAU,CAAC,IAAD,CAAV;MACAE,MAAM,CAAC,KAAD,CAAN;IACH,CAHS,EAGR,IAHQ,CAAV;EAIH,CALD,CAfiB,CAqBjB;;;EACAN,SAAS,CAAC,MAAM;IACZS,aAAa;IACb;EACH,CAHQ,EAGN,EAHM,CAAT,CAtBiB,CA2BjB;;EACA,MAAME,QAAQ,GAAC,MAAI;IACf,IAAGT,KAAK,CAACU,GAAN,KAAY,OAAf,EACIJ,WAAW,CAAC,IAAD,CAAX,CADJ,KAGIA,WAAW,CAAC,KAAD,CAAX;EACP,CALD,CA5BiB,CAmCjB;;;EACAR,SAAS,CAAC,MAAM;IACZW,QAAQ;IACR;EACH,CAHQ,EAGN,CAAET,KAAK,CAACU,GAAR,CAHM,CAAT;EAGmB;EAEnB;;EAEA,IAAGL,UAAU,KAAG,KAAhB,EACI,oBACI;IAAA;EAAA;IAAA;IAAA;IAAA;EAAA,QADJ,CADJ,KAIK,IAAGJ,SAAS,KAAG,KAAf,EAAqB;IACtB,oBACI;MAAK,EAAE,EAAC,KAAR;MAAA;IAAA;MAAA;MAAA;MAAA;IAAA,QADJ,CADC,KAID;IACA,oBACI;MAAK,EAAE,EAAC,KAAR;MAAA,mGAA6BE,GAA7B;IAAA;MAAA;MAAA;MAAA;IAAA,QADJ,CApDa,CAwDjB;AAEH,CA1DD;;GAAMJ,K;;KAAAA,K;AA2DN,eAAeA,KAAf"},"metadata":{},"sourceType":"module"}